Lily Runtime
============

The Lily Runtime is a simple module platform which is used to bootstrap the
lily-server process.

Goal
----

The main goals of the Lily Runtime are:

 * provide coarse-grained modularisation: by splitting up the application into
   a number of modules with clear and controlled dependencies between them,
   we can control complexity.

 * provide encapsulation: each module (which is a jar) is fully self-described
   and can be launched by the Lily Runtime without needing to modify anything
   to Lily. This allows for plugins to be added to Lily.


History
-------

The Lily Runtime is a stripped fork of the Kauri Runtime. So if you would
encounter any references to Kauri, this is where it comes from.


Start-up
--------

When Lily Runtime starts, it reads a conf/runtime/wiring.xml file and boots
up all the modules listed in there. The conf directory is by default searched
in the current working directory, or can be specified via a CLI option.

Anatomy of a module
-------------------

A module is an ordinary jar file, containing two special things in a
LILY-INF directory:

 - a Spring bean container definition (LILY-INF/services/*.xml)
 - a classpath description (LILY-INF/classloader.xml)

The classpath description is usually not written manually, but generated by
the lily-runtime-genclassloader-plugin Maven plugin.

Maven repository usage
----------------------

All references to jar files are based on Maven coordinates (group id,
artifact id, version), and the Lily Runtime looks these up in a Maven
style repository (only on the local file system, it doesn't do downloading
of dependencies).  This makes that all references to jars are file system
location agnostic.

By default the ~/.m2/repository is used (or whatever is specified in
~/.m2/settings.xml), which is handy during development: after building
with "mvn install", the Lily Runtime can be started and will look up
the artifacts it needs in the local Maven repository, so there is no
additional copying/assembling needed.

An alternative location can also be specified, e.g. in the Lily binary
distribution this is the "lib" folder included therein.

Service exports & imports
-------------------------

The different modules can exchange services. If they wouldn't be able to do
this, each module would be an island. A module can make services available
to other modules by exporting them using a lily:export-service directive
in the Spring bean container. Exports can only be based on interfaces,
not classes. A module can depend on a service offered by another module
by importing it using the import-service directive.

Behind the scenes, this export-service and import-service is really not
more complex than adding or getting entries from a Map in which the key
is the Java interface and the value is the spring bean that backs the
interface.

Modules should be listed in the correct order in the wiring.xml so
that dependencies can be satisfied, thus the Lily Runtime will not figure
out the correct startup order itself.

If multiple modules would export a service for the same Java interface,
then import-service will have to decide what implementation to use.
In such case, you will have to wire explicitly in the correct implementation:

    <inject-javaservice name="javaservice-name" service="java interface" ref="module-id:javaservice-name"/>

in which the javaservice names are the names used on the import/export service directives

Dynamically adding modules
--------------------------

If you look in the wiring.xml of lily-server, you will see directives like this:

    <directory id="plugin" basePath="${lily.plugin.dir}" path="load-at-end"/>

What this will do is scan the given directory for *.xml files and treat them
as wiring-style XML files that will be included at the point of the directory
statement. To have a deterministic include order, the files in the directory
will be sorted by their name.

Classloading
------------

The Lily Runtime sets up a classloader per module, and a so-called shared
classloader which is the parent of these per-module classloaders. Any
dependency which is used by more than one module is automatically moved
to the shared classloader.

One of the ideas behind this is that implementation classes of one
module are inaccessible by the other modules.

This classloader system will likely be reviewed to have only a shared classloader,
and not a per-module classloader, as this can sometimes make things more complex
than needed.

If you need to debug classloading problems, it is useful to know that using
the -z CLI option, the structure of the classloader will be dumped.


Configuration
-------------

The Lily Runtime also concerns itself with supplying the modules with
configuration.

For more information on this, please see the old Kauri docs for now:

http://docs.ngdata.com/kauri-docs-current/324-kauri.html

